package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"path/filepath"
	"strings"

	"github.com/sev-2/raiden"
	"github.com/sev-2/raiden/pkg/utils"
	"github.com/valyala/fasthttp"
)

// ----- Define type, var and const -----
type (
	GenerateRouteItem struct {
		Type       string
		Path       string
		Method     string
		Controller string
	}

	GenerateRouterData struct {
		Imports []string
		Package string
		Routes  []GenerateRouteItem
	}

	FoundRoute struct {
		Package string
		Name    string
		Tag     string
	}
)

const (
	RouterFilename = "route.go"
	RouterDir      = "internal/router"
	RouterTemplate = `// Code generated by raiden-cli; DO NOT EDIT.
package {{ .Package }}

{{ if gt (len .Imports) 0 }}
import (
{{- range .Imports}}
	{{.}}
{{- end}}
)
{{ end }}

func Register(server *raiden.Server) {
	server.RegisterRoute([]*raiden.Route{
		{{- range .Routes}}
		{
			Type:       {{ .Type }},
			Path:       {{ .Path }},
			Method:     {{ .Method }},
			Controller: &{{ .Controller }},
		},
		{{- end}}
	})
}
`
)

// Generate route configuration file
func GenerateRoute(basePath string, projectName string, generateFn GenerateFn) error {
	internalFolderPath := filepath.Join(basePath, "internal")
	if exist := utils.IsFolderExists(internalFolderPath); !exist {
		if err := utils.CreateFolder(internalFolderPath); err != nil {
			return err
		}
	}

	routePath := filepath.Join(basePath, RouterDir)
	if exist := utils.IsFolderExists(routePath); !exist {
		if err := utils.CreateFolder(routePath); err != nil {
			return err
		}
	}

	controllerPath, err := utils.GetAbsolutePath(filepath.Join(basePath, ControllerDir))
	if err != nil {
		return err
	}

	// scan all controller
	routes, err := walkScanControllers(controllerPath)
	if err != nil {
		return err
	}

	input, err := createRouteInput(projectName, routePath, routes)
	if err != nil {
		return err
	}

	return generateFn(input)
}

func createRouteInput(projectName string, routePath string, routes []GenerateRouteItem) (input GenerateInput, err error) {
	filePath := filepath.Join(routePath, RouterFilename)
	absolutePath, err := utils.GetAbsolutePath(filePath)
	if err != nil {
		return input, err
	}

	// set imports path
	routeImportPath := fmt.Sprintf("%s/internal/controllers", utils.ToGoModuleName(projectName))
	imports := []string{
		fmt.Sprintf("%q", "github.com/sev-2/raiden"),
		fmt.Sprintf("%q", routeImportPath),
		fmt.Sprintf("%q", "github.com/valyala/fasthttp"),
	}

	// set passed parameter
	data := GenerateRouterData{
		Package: "router",
		Imports: imports,
		Routes:  routes,
	}

	input = GenerateInput{
		BindData:     data,
		Template:     RouterTemplate,
		TemplateName: "routerTemplate",
		OutputPath:   absolutePath,
	}

	return
}

func walkScanControllers(controllerPath string) ([]GenerateRouteItem, error) {
	routes := make([]GenerateRouteItem, 0)
	err := filepath.Walk(controllerPath, func(path string, info fs.FileInfo, err error) error {
		if strings.HasSuffix(path, ".go") {
			r, e := getRoute(path)
			if e != nil {
				return e
			}

			if r.Path != "" {
				routes = append(routes, r)
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	return routes, nil
}

func getRoute(filePath string) (r GenerateRouteItem, err error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return r, err
	}

	// Traverse the AST to find the struct with the Http attribute
	var foundRoute *FoundRoute
	ast.Inspect(file, func(node ast.Node) bool {
		switch t := node.(type) {
		// only check type definition
		case *ast.TypeSpec:
			if t.Name != nil && t.Type != nil {
				// Check if it's a struct
				if st, ok := t.Type.(*ast.StructType); ok {
					// Check if it has the Http attribute
					for _, field := range st.Fields.List {
						for _, fName := range field.Names {
							if fName != nil && fName.Name == "Http" && field.Tag != nil {
								tag := strings.Trim(field.Tag.Value, "`")
								foundRoute = &FoundRoute{
									Name: t.Name.Name,
									Tag:  tag,
								}
								return false // Stop the traversal

							}
						}
					}
				}
			}
		}
		return true
	})

	if foundRoute == nil {
		return r, nil
	}

	// bind package name
	fileDir := filepath.Dir(filePath)
	_, foundRoute.Package = filepath.Split(fileDir)

	return generateRoute(foundRoute)
}

func generateRoute(foundRoute *FoundRoute) (GenerateRouteItem, error) {
	r := GenerateRouteItem{}

	r.Controller = fmt.Sprintf("%s.%s{}", foundRoute.Package, foundRoute.Name)
	tagItems := strings.Split(foundRoute.Tag, " ")

	for _, tagItem := range tagItems {
		items := strings.Split(tagItem, ":")
		if len(items) != 2 {
			continue
		}

		trimmedItem := strings.Trim(items[1], "\"")
		switch items[0] {
		case "verb":
			switch strings.ToUpper(trimmedItem) {
			case fasthttp.MethodGet:
				r.Method = "fasthttp.MethodGet"
			case fasthttp.MethodPost:
				r.Method = "fasthttp.MethodPost"
			case fasthttp.MethodPatch:
				r.Method = "fasthttp.MethodPatch"
			case fasthttp.MethodPut:
				r.Method = "fasthttp.MethodPut"
			case fasthttp.MethodDelete:
				r.Method = "fasthttp.MethodDelete"
			default:
				return r, fmt.Errorf("%s.%s : unsupported http method %s", foundRoute.Package, foundRoute.Name, items[1])
			}
		case "path":
			r.Path = fmt.Sprintf("%q", trimmedItem)
		case "type":
			switch trimmedItem {
			case string(raiden.RouteTypeFunction):
				r.Type = "raiden.RouteTypeFunction"
			case string(raiden.RouteTypeHttpHandler):
				r.Type = "raiden.RouteTypeHttpHandler"
			case string(raiden.RouteTypeRpc):
				r.Type = "raiden.RouteTypeRpc"
			default:
				return r, fmt.Errorf(
					"%s.%s : unsupported route type %s, available type are %s, %s, and %s ",
					foundRoute.Package, foundRoute.Name, items[1], raiden.RouteTypeFunction, raiden.RouteTypeHttpHandler, raiden.RouteTypeRpc,
				)
			}
		}
	}
	return r, nil
}
